---
title: 'Bowen et al. 2017 Progress Report' 
author: "Sean Lee"
date: "10/3/2020"
output: html_document
---
##Week 1

##Data acquisition

My goal for this assignment was to create the Structural Equation Model (SEM) as shown in Bowen et al. 2017.  The first step in doing so would require me to get the raw data and code associated with creating this SEM.  Luckily for me, I found the a github link to the data and code imbedded in the methods section (https://github.com/jebyrnes/phrag_common_garden_sem).  

##Function parsing & correlation

After opening the link I found that it took me to a github page with a "data" folder and a "r" folder which held the code used.  I created a new project and created a data folder with all the github data in it so I could read it in later on.  I imported all the scripts which were seperated into 3 parts, part 1 included "function parsing" and "function correlation" scripts.  Function parse from what I can tell is cleaning up the data and seperating into new dataframes that will be used for downstream pathway analysis
```{r Function Parse, include=FALSE}
library(dplyr)
library(readxl)
library(tidyr)

#was functions for Jarrett originally, but the data was too correlated
func_data <- read_excel("./data/Final picrust.xlsx")


#split up the pathway types for future grouping
func_data <- separate(func_data, KEGG_Pathways, "; ", into=c("Pathway", "Subpathway", "Specific_Pathway"))
func_data <- func_data[,-1] #get rid of redundant column

#reshape to long format
func_data_long <- gather(func_data, "SampleID", "Abundance", -Pathway, -Subpathway, -Specific_Pathway)
func_data_long$SampleID <- as.character(func_data_long$SampleID)

#some summary data frames
pathway_data <- group_by(func_data_long, SampleID, Pathway) %>%
  dplyr::summarise(sum_abund = sum(Abundance, na.rm=T), mean_abund = mean(Abundance, na.rm=T)) 

#Make it wide again
pathway_data_sum <- dplyr::select(pathway_data, -mean_abund) %>%
  spread(Pathway, sum_abund)


pathway_data_mean <- dplyr::select(pathway_data, -sum_abund) %>%
  spread(Pathway, mean_abund)


subpathway_data <- group_by(func_data_long, SampleID, Subpathway) %>%
  dplyr::summarise(sum_abund = sum(Abundance, na.rm=T), mean_abund = mean(Abundance, na.rm=T))

subpathway_data_sum <- dplyr::select(subpathway_data, -mean_abund) %>%
  spread(Subpathway, sum_abund)
```

## Function correlation

This function correlation script is the script for creating the correlation maps of different biological processes and how they affect other biological processes.  It is unrelated to the SEM model.

```{r Function correlation}
library(ggplot2)
library(RColorBrewer)



###Correlation Data Frames
cor_pathways_sum <- data.frame(cor(pathway_data_sum[,-1])) %>%
  mutate(V2 = rownames(.)) %>%
  gather(V1, correlation, -V2)

cor_subpathways_sum <- data.frame(cor(subpathway_data_sum[,-1])) %>%
  mutate(V2 = rownames(.)) %>%
  gather(V1, correlation, -V2)


func_data_transpose <- select(func_data, -Pathway, -Subpathway) %>%
  gather(SampleID, Abundance, -Specific_Pathway) %>%
  spread(Specific_Pathway, Abundance)

cor_raw_pathways <- data.frame(cor(func_data_transpose[,-1])) %>%
  mutate(V2 = rownames(.)) %>%
  gather(V1, correlation, -V2)

###PLOTS
pairs(pathway_data_sum[,-1])

ggplot(data=cor_pathways_sum, mapping=aes(x=V1, y=V2, fill=correlation)) +
  geom_tile() +
  scale_fill_gradientn(colours=brewer.pal(11, "BrBG"), limits=c(-1,1))+ 
  theme(axis.text.x = element_text(angle=90, hjust=1, vjust=0.5))



ggplot(data=cor_subpathways_sum, mapping=aes(x=V1, y=V2, fill=correlation)) +
  geom_tile() +
  scale_fill_gradientn(colours=brewer.pal(11, "BrBG"), limits=c(-1,1))+ 
  theme(axis.text.x = element_text(angle=90, hjust=1, vjust=0.5))


ggplot(data=cor_raw_pathways, mapping=aes(x=V1, y=V2, fill=correlation)) +
  geom_tile() +
  scale_fill_gradientn(colours=brewer.pal(11, "BrBG"), limits=c(-1,1)) #+ 
# theme(axis.text.x = element_text(angle=90, hjust=1, vjust=0.5))
```

## Data load : merge

The second script in the "r" folder is a script named data load:merge which just seems to be merging the experimental data from the common garden experiment to the pathway summary data created from the function parse script.

```{r}

exp_data <- read_excel("./data/common_garden_data.xlsx", sheet=2) %>%
  dplyr::rename(SampleID = `#SampleID`)

exp_data_func <- inner_join(exp_data, pathway_data_sum)

```

##SEM

The SEM model script will run until the sem.fit function at which time there is an error that indicates that that function doesn't exist.  I assume that it is an old function but I cannot find how to format the new function.

```{r}
###### Load Libraries for analysis
library(nlme)
library(lsmeans)
library(piecewiseSEM)
library(car)

###### Load data

exp_data_func <- as.data.frame(exp_data_func)

###some useful functions for piecewiseSEM use
resp <- function(i) Reduce(paste, deparse(formula(i)[[2]]))


sem.anova <- function(modlist){
  data.frame(purrr::map_df(modlist, ~{
    a <- as.data.frame(Anova(.))
    a$predictor <- rownames(a)
    a$response <- resp(.)
    a %>%
      select(response, predictor, Chisq, Df, `Pr(>Chisq)`) %>%
      rename(p_value = `Pr(>Chisq)`) %>%
      mutate(Chisq = round(Chisq,4), p_value = round(p_value, 4))
  }))
}

status_lsmeans <- function(x, ...){
  r <- resp(x)
  ret <- lsmeans(x, list(pairwise ~ status), ...)
  names(ret) <- r
  ret
}

######################### THIS IS WHAT I RAN FOR THE MODEL
exp_data_func$rd <- exp_data_func$`RNA/DNA`
exp_data_func$belowC <- exp_data_func$`below%C`
exp_data_func$belowN <- exp_data_func$`below%N`
gen_div_status <- lme(observed_otus~  status, 
                      random =~ 1|Genotype, data=exp_data_func, method="ML")
gen_activity_status <- lme(rd ~ status + observed_otus, 
                           random =~ 1|Genotype, data=exp_data_func, method="ML")
gen_meta_status <- lme(`Metabolism`~ status+ observed_otus, 
                       random =~ 1|Genotype, data=exp_data_func, method="ML")
phen_mod_status <- lme(belowgallic_uM ~ rd + observed_otus + Metabolism + status, 
                       random =~ 1|Genotype, data=exp_data_func, method="ML")
c_mod_status <- lme(belowC ~ rd + observed_otus + Metabolism + status + belowgallic_uM +
                      belowbiomass_g + abovebiomass_g, 
                     random =~ 1|Genotype, data=exp_data_func, method="ML")
n_mod_status <- lme(belowN ~ rd + observed_otus + Metabolism + status +
                      belowbiomass_g + abovebiomass_g, 
                     random =~ 1|Genotype, data=exp_data_func, method="ML")

biomass_mod_status <- lme(belowbiomass_g ~ rd + belowgallic_uM +  
                            observed_otus + Metabolism + status, 
                          random =~ 1|Genotype, data=exp_data_func, method="ML")
Abiomass_mod_status <- lme(abovebiomass_g ~ rd + belowgallic_uM + 
                             observed_otus + Metabolism + status, 
                           random =~ 1|Genotype, data=exp_data_func, method="ML")

sem_mod_nlme <- list(
  gen_div_status,
  gen_activity_status,
  gen_meta_status,
  phen_mod_status,
  c_mod_status,
  n_mod_status,
  biomass_mod_status,
  Abiomass_mod_status
  
)

#get SEM fit information
sem.fit(sem_mod_nlme, data=exp_data_func, 
        corr.errors=c("belowbiomass_g~~abovebiomass_g", "belowN ~~ belowC"))
        
#Get coefficients from the fit model
sem.coefs(sem_mod_nlme, data=exp_data_func, 
          corr.errors=c("belowbiomass_g~~abovebiomass_g", "belowN ~~ belowC"),
          intercept=T)

#Evaluate Chi Square tests of parameter significance
sem.anova(sem_mod_nlme)
write.csv(sem.anova(sem_mod_nlme), "./sem_chisq.csv", row.names=FALSE)

ph_tests <- lapply(sem_mod_nlme, status_lsmeans, adjust="none")
ph_comp <- lapply(ph_tests, function(x) x[[2]])
names(ph_comp) <- sapply(ph_tests, function(x) names(x)[1])


ph_comp_tab <- do.call(rbind, lapply(ph_comp, function(x) as.data.frame(print(x))))
write.csv(ph_comp_tab, "./post_hocs.csv", row.names=TRUE)

#### Get coefficients, including categorical means
sem_mod_coefs <- lapply(sem_mod_nlme, function(x) update(x, . ~ . - 1))

ctab <- sem.coefs(sem_mod_coefs, data=exp_data_func, 
                  corr.errors=c("belowbiomass_g~~abovebiomass_g", "belowN ~~ belowC"),
                      intercept=T)
ctab <- data.frame(ctab) %>%
  arrange(response, predictor)
write.csv(ctab, "./sem_coefs.csv", row.names=FALSE)



std_ctab <- sem.coefs(sem_mod_coefs, data=exp_data_func, 
                      corr.errors=c("belowbiomass_g~~abovebiomass_g", "belowN ~~ belowC"),
                      standardize="range", intercept=T)
std_ctab <- data.frame(std_ctab) %>%
  arrange(response, predictor)
write.csv(std_ctab, "./sem_std_coefs.csv", row.names=FALSE)
```

## Week 2

To this point I have downloaded all the data and scripts from
github and have ran through all of the "Function parsing and correlations" which broke down the data and created correlation maps of different biological processes and how they affect other biological processes.  These again are unrelated to the final SEM model I am interested in.

## The problem

The main problem I had last week was that all the previous scripts leading up the the SEM model were running perfectly, but when it came to the SEM model there was an error that popped up.  The error read: 

Error in sem.fit(sem_mod_nlme, data = exp_data_func, corr.errors = c("belowbiomass_g~~abovebiomass_g",  : 
  could not find function "sem.fit"
  
It seems as though the sem.fit function has since been replaced by a new function or somehow the syntax of the new version may be different.  Looking back to when the author originally used the "piecewiseSEM" package they were likely using version 1.x, and the current package my system has loaded in verion 2.1.0. 

To find how the "piecewiseSEM" package has changed from verion 1.x to 2.1.0 I looked up "piecewiseSEM" on google to find a page from "The Comprehensize R Archive Network" (https://cran.r-project.org/web/packages/piecewiseSEM/vignettes/piecewiseSEM.html) which describes how to use the "piecewiseSEM" package.  

In section 3.2 "Comparing versions in evaluating the Shipley’s SEM" the author describes that the old version of the package the model was run off of a constructed "list" of linear models.  For example from bowen et al. 2017:
```{r}
gen_div_status <- lme(observed_otus~  status, 
                      random =~ 1|Genotype, data=exp_data_func, method="ML")
  gen_activity_status <- lme(rd ~ status + observed_otus, 
                           random =~ 1|Genotype, data=exp_data_func, method="ML")
  gen_meta_status <- lme(`Metabolism`~ status+ observed_otus, 
                       random =~ 1|Genotype, data=exp_data_func, method="ML")
  phen_mod_status <- lme(belowgallic_uM ~ rd + observed_otus + Metabolism + status, 
                       random =~ 1|Genotype, data=exp_data_func, method="ML")
  c_mod_status <- lme(belowC ~ rd + observed_otus + Metabolism + status + belowgallic_uM     +
                      belowbiomass_g + abovebiomass_g, 
                    random =~ 1|Genotype, data=exp_data_func, method="ML")
  n_mod_status <- lme(belowN ~ rd + observed_otus + Metabolism + status +
                      belowbiomass_g + abovebiomass_g, 
                    random =~ 1|Genotype, data=exp_data_func, method="ML")

  biomass_mod_status <- lme(belowbiomass_g ~ rd + belowgallic_uM +  
                            observed_otus + Metabolism + status, 
                          random =~ 1|Genotype, data=exp_data_func, method="ML")
  Abiomass_mod_status <- lme(abovebiomass_g ~ rd + belowgallic_uM + 
                             observed_otus + Metabolism + status, 
                           random =~ 1|Genotype, data=exp_data_func, method="ML")

  sem_mod_nlme <- list(
    gen_div_status,
    gen_activity_status,
    gen_meta_status,
    phen_mod_status,
    c_mod_status,
    n_mod_status,
    biomass_mod_status,
    Abiomass_mod_status
  
    )
```

    
This created a list of all the linear models fed into the SEM model called "sem_mod_nmle". 

## Solving the problem from last week

The new version of the the package omits the list and uses the "psem" function which converts the list into this "psem" object.  So I edited the chunk of code seed above to this new one:
```{r}
bowen.psem<-psem(lme(observed_otus~  status, 
                                       random =~ 1|Genotype, data=exp_data_func, method="ML"),
                 lme(rd ~ status + observed_otus, 
                                            random =~ 1|Genotype, data=exp_data_func, method="ML"),
                 lme(`Metabolism`~ status+ observed_otus, 
                                        random =~ 1|Genotype, data=exp_data_func, method="ML"),
                 lme(belowgallic_uM ~ rd + observed_otus + Metabolism + status, 
                                        random =~ 1|Genotype, data=exp_data_func, method="ML"),
                 lme(belowC ~ rd + observed_otus + Metabolism + status + belowgallic_uM +
                                       belowbiomass_g + abovebiomass_g, 
                                     random =~ 1|Genotype, data=exp_data_func, method="ML"),
                 lme(belowN ~ rd + observed_otus + Metabolism + status +
                                       belowbiomass_g + abovebiomass_g, 
                                     random =~ 1|Genotype, data=exp_data_func, method="ML"),
                 lme(belowbiomass_g ~ rd + belowgallic_uM +  
                                             observed_otus + Metabolism + status, 
                                           random =~ 1|Genotype, data=exp_data_func, method="ML"),
                 lme(abovebiomass_g ~ rd + belowgallic_uM + 
                                              observed_otus + Metabolism + status, 
                                            random =~ 1|Genotype, data=exp_data_func, method="ML"))

  (sem_mod_nlme <- summary(bowen.psem, .progressBar = F))
  
```

 
##Getting the coefficients from the fit model

The "sem.coefs" function used by Bowen et al. 2017 was also out of date so I checked the CRAN page to see what the new procedure was.  The new function is simply "coefs" and you plug your "psem" object right into it.  So I ran coefs(bowen.psem) and got:

```{r}
coefs(bowen.psem)
```


## Where I am now

   There are correlation errors inputed into each of the sem.fit and sem.coef functions the author wrote, I did not integrate those into the new fit model or the coefficients I ran, how does that affect my model and how can I address that?

